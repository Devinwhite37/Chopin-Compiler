<!DOCTYPE HTML>
<html>
	
<head>
    <title>Chopin Compiler</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="source/styles/compiler.css" />
    <link rel="stylesheet" href="source/styles/bootstrap.min.css">
</head>

<body style="background-image: url(source/images/IMG_2468.jpg); background-repeat: repeat; background-size: cover;" onload="init();">
	<nav class="topbar navbar navbar-expand-lg navbar-light bg-primary sticky-top">
		<h1 style="font-family:cursive; text-align: center; color:black; font-size: 400%; font-style: italic;">ùÑû       Chopin Compiler   </h1>
	<h1> </h1>
	</nav>
</div>
	<span class="page">
	<div style="margin: 0 auto; display: table;">
		<table>
			<tr>
				<th><h4 style="font-family:cursive; text-align: center; color:black; font-style: italic; font-weight: bold;">Nocturne in E Flat Major</h4></th>
				<th><h4 style="font-family:cursive; text-align: center; color:black; font-style: italic; font-weight: bold;">Nocturne in C Sharp Minor</h4></th>
				<th><h4 style="font-family:cursive; text-align: center; color:black; font-style: italic; font-weight: bold;">Nocturne in B Flat Minor</h4></th>
			  </tr>
			  <tr>
				  <td>
	<audio controls style="padding: 3%;">
		<source src="source/audio/nocturne_E_flat_major.mp3" type="audio/mpeg">
		<source src="source/audio/nocturne_E_flat_major.mp3" type="audio/ogg">
		<source src="source/audio/nocturne_E_flat_major.mp3" type="audio/wav">
	</audio>
	</td>
	<td>
	<audio controls style="padding: 3%;"> 
		<source src="source/audio/nocturne_C_sharp_minor.mp3" type="audio/mpeg">
		<source src="source/audio/nocturne_C_sharp_minor.mp3" type="audio/ogg">
		<source src="source/audio/nocturne_C_sharp_minor.mp3" type="audio/wav">
	</audio>
	</td>
	<td>
	<audio controls style="padding: 3%;">
		<source src="source/audio/nocturne_B_flat_minor.mp3" type="audio/mpeg">
		<source src="source/audio/nocturne_B_flat_minor.mp3" type="audio/ogg">
		<source src="source/audio/nocturne_B_flat_minor.mp3" type="audio/wav">
	</audio>
	</td>
	</table>
	</div>
	<hr style = "color:black;">
	
    <h3 style = "text-align:center; font-family: cursive; font-weight: bold; font-style: italic; color:black">A classical compiler featuring some of Chopin's finest works.</h3>

    <div style="text-align:center;">
        <input style="border:solid 1px black; font-family:cursive; font-weight: bold; font-size: 150%" type="button" id="btnCompile" value="~Compile~" onclick="btnCompile_click();"/>
    </div>

    <div>
        <div class="source">
			<table class = "center">
				<tr>
					<td><h3 style = "font-family: 'Courier New', Courier, monospace; color: black; margin-left: 20px; font-weight: bold;">Input</h3></td>
					<td><h3 style = "font-family: 'Courier New', Courier, monospace; color: black; margin-left: 20px; font-weight: bold;">Output</h3></td>
				</tr>
				<tr>
					<td><textarea class="lined" id="taSourceCode" autofocus></textarea></td>
					<td><textarea id="taOutput" readonly></textarea></td>
				</tr>
				<tr>
					<td><h3 style = "font-family: 'Courier New', Courier, monospace; color: black; margin-left: 20px; font-weight: bold;">CST</h3></td>
					<td><h3 style = "font-family: 'Courier New', Courier, monospace; color: black; margin-left: 20px; font-weight: bold;">AST</h3></td>
				</tr>
				<tr>
					<td><textarea id="taCST" readonly></textarea></td>
					<td><textarea id="taAST" readonly></textarea></td>
				</tr>
			</table>
		</div>        
	</div>
	<h5 style = "font-family: 'Courier New', Courier, monospace; color: black; margin-left: 10px; font-weight: bold;">A Compiler by Devin H White</h5>
	<h5 style = "font-family: 'Courier New', Courier, monospace; color: black; margin-left: 10px; font-weight: bold;">¬© 2022 Chopin Compiler</h5>

	
	
	

    <!--<div>
        <img style="display:block; margin-left:auto; margin-right:auto;"
		       src="dist/images/CompilerPhases.png" 
				 alt="Compiler Phases" />
    </div>  --> 

    <!-- Client-side code down here, per the YSlow advice. -->
    <script type="text/javascript" src="source/scripts/utils.js"></script>	
    <script type="text/javascript" src="source/scripts/lexer.js"></script>	
	<script type="text/javascript" src="source/scripts/globals.js"></script>	
	<script type="text/javascript" src="source/scripts/parser.js"></script>	

	<!--<script type="text/javascript" src="source/scripts/tokenizer.js"></script>	-->


    <script type="text/javascript">
		 function init() {
	        // Clear the message box.
			document.getElementById("taOutput").value = "";
			document.getElementById("taCST").value = "";

	        // Set the initial values for our globals.
	        tokens = "";
	        tokenIndex = 0;
	        currentToken = ' ';
	        errorCount = 0;        
	    }
    
	    function btnCompile_click() {        
	        // This is executed as a result of the user pressing the 
	        // "compile" button between the two text areas, above.  
	        // Note the <input> element's event handler: onclick="btnCompile_click();
			init();

			let lexer = new TSC.Lexer();
	        // Grab the tokens from the lexer . . .
			//tokens = _Lexer.lex();
			tokens = lexer.lex();
			programNum = 1;

			console.log("HTML TOKENS:");
			console.log(tokens);
			let parser = new TSC.Parser();
			productions = parser.parse();
			console.log(productions); 
			// . . . and parse!
			
	        compile();
	    }
    
	    function putMessageOP(msgOP) {
			document.getElementById("taOutput").value += msgOP + "\n";
		}

		function putMessageCST(msgCST) {
			document.getElementById("taCST").value += msgCST + "\n";
		}

		function putMessageAST(msgCST) {
			document.getElementById("taAST").value += msgCST + "\n";
		}
		
		function compile(){
			if (tokens[0] == undefined){
				putMessageOP("Well that's random. Try compiling some code next time.");
				putMessageCST("No CST to show.");
				putMessageAST("No AST to show.");

			}
			else{
				//putMessageOP("Compilation Started");
				lexOutput();
				cstOutput();
			}
		}
		function lexOutput(){
			var errors = 0;
			var warnings = 0;
			var i = 0;
			var l = 0;

			for(var j = 0; j < programNum; j++){

				if(tokens[i+1] === undefined){
					return;
				}
				else{
					putMessageOP(" ____________________________________________ ")
					putMessageOP("     -------- COMPILING PROGRAM " + programNum + " --------");
					putMessageOP("\n Lexing Program "+ programNum);
					putMessageOP("---------------------------")
				}
				for(var i; i < tokens.length; i++){
					if(tokens[i][0] == 'INVALID_CHAR'){
						errors++;
						putMessageOP("LEXER -> | ERROR: Invalid Token [ " + tokens[i][1] + " ]  on [ " + tokens[i][2] + " , " + tokens[i][3] + " ]");
						putMessageOP("Lexical Analysis stopped due to error.")
						break;
					}
					else if(tokens[i][0] == 'missingCommentEnd'){
						errors++;
						putMessageOP("LEXER -> | ERROR: Missing Comment End");
						putMessageOP("Lexical Analysis stopped due to error.")
						break;
					}
					else if(tokens[i][0] == 'missingQuoteEnd'){
						errors++;
						putMessageOP("LEXER -> | ERROR: Missing Quote End");
						putMessageOP("Lexical Analysis stopped due to error.")
						break;
					}
					else if(tokens[i][0] == 'missingEOP'){
						warnings++;
						putMessageOP("LEXER -> | WARNING: Missing EOP [ $ ] at end of file.");
					}
					else if(tokens[i][0] == 'EOP'){
						putMessageOP("LEXER -> | " + tokens[i][0] + "  [ " + tokens[i][1] + " ]  on [ " + tokens[i][2] + " , " + tokens[i][3] + " ]");
						errors = 0;
						warnings = 0;
						i = i+1;
						break;
						//putMessageOP("---------------------------");
						//putMessageOP("Lexical analysis complete with " + errors + " error(s) and " + warnings + " warning(s).");
					}
					else{
						putMessageOP("LEXER -> | " + tokens[i][0] + "  [ " + tokens[i][1] + " ]  on [ " + tokens[i][2] + " , " + tokens[i][3] + " ]");
					}	
				}
						//putMessageOP("---------------------------");
						putMessageOP("\nLexical analysis complete with " + errors + " error(s) and " + warnings + " warning(s).\n");

							putMessageOP(" Parsing Program "+ programNum);
							putMessageOP("---------------------------")
							for(var l; l < productions.length; l++){
								if(productions[l] == 'VALID - Found [EOP]'){
									programNum++;
									putMessageOP("PARSER -> " + productions[l]);
									putMessageOP("\n")
									l++;
									break;
								}
								else{
									putMessageOP("PARSER -> " + productions[l]);
								}
							}
				}
		}    
		function cstOutput(){
			putMessageCST("<Program 1>");

		}
		
		/*function parseOutput(){
			putMesage("Begin Parsing:");
			for(var i = 0; i < productions.length; i++){
				putMessageOP("PARSER -> | " + productions[i]);
			}
		}*/
	
	 	 // TODO: These parse routines really should be in TypeScript.
		 //       This exercise is left to the student. Consider it project 0.5 .
	    /*function parse() {
	        putMessageOP("Parsing [" + tokens + "]");
	        // Grab the next token.
	        currentToken = getNextToken();
	        // A valid parse derives the G(oal) production, so begin there.
	        parseG();
	        // Report the results.
	        putMessageOP("Parsing found " + errorCount + " error(s).");        
	    }
    
	    function parseG() {
	        // A G(oal) production can only be an E(xpression), so parse the E production.
	        parseE();
	    }

	    function parseE() {
	        // All E productions begin with a digit, so make sure that we have one.
	        checkToken("digit");
	        // Look ahead 1 char (which is now in currentToken because checkToken 
	        // consumes another one) and see which E production to follow.
	        if (currentToken != EOF) {
	            // We're not done, we expect to have an op.
	            checkToken("op");
	            parseE();
	        } else {
	            // There is nothing else in the token stream, 
	            // and that's cool since E ::== digit is valid.
	            putMessageOP("EOF reached");
	        }
	    }*/

	    function checkToken(expectedKind) {
	        // Validate that we have the expected token kind and et the next token.
	        switch(expectedKind) {
	            case "digit":   putMessageOP("Expecting a digit");
	                            if (currentToken=="0" || currentToken=="1" || currentToken=="2" || 
	                                currentToken=="3" || currentToken=="4" || currentToken=="5" || 
	                                currentToken=="6" || currentToken=="7" || currentToken=="8" || 
	                                currentToken=="9")
	                            {
									putMessageOP("Got a digit!");
									console.log("digit");
	                            }
	                            else
	                            {
	                                errorCount++;
	                                putMessageOP("NOT a digit.  Error at position " + tokenIndex + ".");
	                            }
	                            break;
	            case "op":      putMessageOP("Expecting an operator");
	                            if (currentToken=="+" || currentToken=="-")
	                            {
	                                putMessageOP("Got an operator!");
	                            }
	                            else
	                            {
	                                errorCount++;
	                                putMessageOP("NOT an operator.  Error at position " + tokenIndex + ".");
	                            }
	                            break;
	            default:        putMessageOP("Parse Error: Invalid Token Type at position " + tokenIndex + ".");
	                            break;			
	        }
	        // Consume another token, having just checked this one, because that 
	        // will allow the code to see what's coming next... a sort of "look-ahead".
	        currentToken = getNextToken();
	    }

	    function getNextToken() {
	        var thisToken = EOF;    // Let's assume that we're at the EOF.
	        if (tokenIndex < tokens.length)
	        {
	            // If we're not at EOF, then return the next token in the stream and advance the index.
	            thisToken = tokens[tokenIndex];
	            putMessageOP("Current token:" + thisToken);
	            tokenIndex++;
	        }
	        return thisToken;
	    }
    </script>
</body>
</html>