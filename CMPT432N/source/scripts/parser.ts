

module TSC {
    export enum Production {
        Program = "Program",
        Block = "Block",
        Expr = "Expression",
        Stmt = "Statement",
        StmtList = "StatementList",
        AssignStmt = "AssignmentStatement",
        PrintStmt = "PrintStatement",
        WhileStmt = "WhileStatement",
        VarDecl = "VarDecl",
        IfStmt = "IfStatement",
        BooleanExpr = "BooleanExpression",
        IntExpr = "IntegerExpression",
        StringExpr = "StringExpression",
        CharList = "CharList",
        Id = "Id",
        BoolVal = "BoolVal",
        Type = "Type",
        Char = "Char",
        Digit = "Digit",
        IntOp = "IntOp",
        BoolOp = "BoolOp",
        Space = "Space",
        Addition = "Addition"
    }
        export class Parser {
            currentToken: number; 
            tokenList: Array<Lexer>; 
            parseOutput: Array<String>; 
            error: boolean; 
            i: number;

            // Constructor for parser, passed tokens from lexer. Inits values.
            constructor(tokens){
                this.tokenList = tokens;
                // Set current token to the first token in the list
                this.currentToken = 0;
                // Holds log messages generated by parser
                this.parseOutput = [];
                // Flag for parser error
                this.error = false;
                this.i = 0;
                // Tree data structure
                //this.cst = new Tree();

            }
            public parse() { 
                this.parseBlock();
                //this.statmentList();
                console.log("parse");
                return this.parseOutput;
            }

            public parseBlock() {
                if(tokens[this.i][1]!=""){
                    this.parseOutput.push("VALID - Expecting [Program], found [Block] on [ " + tokens[this.i][2] + " , " + tokens[this.i][3] + " ]");
                    for(this.i = 0; this.i < tokens.length; this.i++){
                        if(tokens[this.i][1] == '{'){
                            this.parseOutput.push("VALID - Expecting [L_BRACE], found [{] on [ " + tokens[this.i][2] + " , " + tokens[this.i][3] + " ]");
                            //this.i++;
                            this.statmentList();
                            //break;
                        }
                        else if(tokens[this.i][1] == '}'){
                            this.parseOutput.push("VALID - Expecting [R_BRACE], found [}] on [ " + tokens[this.i][2] + " , " + tokens[this.i][3] + " ]");
                            //break;
                        }
                        else if(tokens[this.i][1] == '$'){
                            this.parseOutput.push("VALID - Expecting [EOP], found [$] on [ " + tokens[this.i][2] + " , " + tokens[this.i][3] + " ]");
                            this.parseBlock();
                        }
                    }  
                }
                else{}
        }
            public statmentList(){
                for(this.i = 0; this.i < tokens.length; this.i++){
                    if(tokens[this.i][1] == 'print'){
                        this.i--;
                        this.printStatement();
                    }
                    else if(tokens[this.i][2] == 'VARIABLE'){
                        this.assignmentStatement();
                    }
                    else if(tokens[this.i+1][1] == '}' || tokens[this.i+1][1] =='{'){
                        //this.i++;
                        console.log("epsilon");
                        this.parseOutput.push("VALID - Found Îµ on [ " + tokens[this.i][2] + " , " + tokens[this.i][3] + " ]");
                        //this.parseBlock();
                        break;
                    }
                    //else if(tokens[this.i][2] == '')
            }
        }
            public printStatement(){
                for(this.i = 0; this.i < tokens.length; this.i++){
                    if(tokens[this.i][1] == 'print'){
                        this.parseOutput.push("VALID - Expecting [Program], found [this]");
                    }
                    else if(tokens[this.i][1] == '('){

                    }
                }
            }
            public assignmentStatement(){

            }
    }
}