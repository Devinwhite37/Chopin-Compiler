

module TSC {
    export enum Production {
        Program = "Program",
        Block = "Block",
        Expr = "Expression",
        Stmt = "Statement",
        StmtList = "StatementList",
        AssignStmt = "AssignmentStatement",
        PrintStmt = "PrintStatement",
        WhileStmt = "WhileStatement",
        VarDecl = "VarDecl",
        IfStmt = "IfStatement",
        BooleanExpr = "BooleanExpression",
        IntExpr = "IntegerExpression",
        StringExpr = "StringExpression",
        CharList = "CharList",
        Id = "Id",
        BoolVal = "BoolVal",
        Type = "Type",
        Char = "Char",
        Digit = "Digit",
        IntOp = "IntOp",
        BoolOp = "BoolOp",
        Space = "Space",
        Addition = "Addition"
    }
        export class Parser {
            currentToken: number; 
            tokenList: Array<Lexer>; 
            parseOutput: Array<String>; 
            error: boolean; 
            i: number;

            // Constructor for parser, passed tokens from lexer. Inits values.
            constructor(tokens){
                this.tokenList = tokens;
                //tokens = this.tokenList;
                // Set current token to the first token in the list
                this.currentToken = 0;
                // Holds log messages generated by parser
                this.parseOutput = [];
                // Flag for parser error
                this.error = false;
                this.i = 0;
                // Tree data structure
                //this.cst = new Tree();

            }
            public parse() { 
                this.parseBlock();
                //this.statmentList();
                return this.parseOutput;
            }

            public parseBlock() {
                if(tokens[this.i][1]!=""){
                    this.parseOutput.push("Block");
                    for(this.i = this.i; this.i < tokens.length; this.i++){
                        if(tokens[this.i][1] == '{'){
                            this.parseOutput.push("VALID - Expecting [L_BRACE], found [{] on [ " + tokens[this.i][2] + " , " + tokens[this.i][3] + " ]");
                            this.i++;
                            this.statmentList();
                            if(tokens[this.i][1] == '}'){
                                this.parseOutput.push("VALID - Expecting [R_BRACE], found [}] on [ " + tokens[this.i][2] + " , " + tokens[this.i][3] + " ]");
                                this.i++;
                                if(tokens[this.i][1] == '$'){
                                    this.parseOutput.push("VALID - Expecting [EOP], found [$] on [ " + tokens[this.i][2] + " , " + tokens[this.i][3] + " ]");
                                }
                                else if(tokens[this.i][0] != '$'){
                                    this.parseOutput.push("ERROR - Expecting [EOP]");
                                    break;
                                }
                            }
                            else if(tokens[this.i][1] != '}'){
                                this.parseOutput.push("ERROR - Expecting [}]");
                                break;
                            }
                        }
                        else if(tokens[this.i][1] != '{'){
                            this.parseOutput.push("ERROR - Expecting [{]");
                            break;
                        }
                    }  
                }
                else{}
        }
            public statmentList(){
                this.parseOutput.push("StatementList");
                for(this.i = this.i; this.i < tokens.length; this.i++){
                    console.log("token: " + tokens[this.i][1]);
                    if(tokens[this.i][1] == 'print'){
                        //this.i--;
                        this.printStatement();
                    }
                    else if(tokens[this.i][0] == 'VARIABLE'){
                        console.log("Assignment Ran");
                        this.assignmentStatement();
                    }
                    else if(tokens[this.i+1][1] == '}' || tokens[this.i+1][1] =='{'){
                        //this.i++;
                        console.log("epsilon");
                        this.parseOutput.push("VALID - Found Îµ on [ " + tokens[this.i][2] + " , " + tokens[this.i][3] + " ]");
                        //this.parseBlock();
                        break;
                    }
                    /*else if(tokens[this.i][1] == undefined){
                        break;
                    }*/

                    //else if(tokens[this.i][2] == '')
            }
        }
            public printStatement(){
                this.parseOutput.push("PrintStatement");
                for(this.i = this.i; this.i < tokens.length; this.i++){
                    if(tokens[this.i][1] == 'print'){
                        this.parseOutput.push("VALID - Expecting [PRINT], found [print]");
                    }
                    else if(tokens[this.i][0] == 'missingEOP'){
                    }
                    else if(tokens[this.i][1] == '('){
                        this.parseOutput.push("VALID - Expecting [R_PAREN], found [(]");
                    }
                    else if(tokens[this.i][1] != '('){
                        this.parseOutput.push("ERROR - Expecting [R_PAREN], found ["+ tokens[this.i][0]+"]");
                    }
                    else if(tokens[this.i][0] == 'DIGIT' || 'VARIABLE'){
                        this.parseOutput.push("VALID - Expecting [EXPR], found [" + tokens[this.i][0] + "]");
                    }
                    else if(tokens[this.i][1] == ')'){
                        this.parseOutput.push("VALID - Expecting [L_PAREN], found [)]");
                    }

                    
                }
            }
            public assignmentStatement(){
                console.log("AssiGNMENT RAN");
                this.parseOutput.push("AssignmentStatement");

            }
    }
}